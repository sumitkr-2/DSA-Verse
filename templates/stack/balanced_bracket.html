<!DOCTYPE html>
<html>
<head>
	<title>Balanced Bracket - DSA Verse</title>
	<meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
	
	<style>
		:root {
			--primary-color: #4ade80; /* Green for match */
			--dark-bg: #111827;
			--light-dark-bg: #1f2937;
			--card-bg: rgba(31, 41, 55, 0.5);
			--text-color: #e5e7eb;
			--border-color: rgba(255, 255, 255, 0.1);
			--scan-color: #facc15; /* Yellow for scanning */
			--fail-color: #f87171; /* Red for fail */
		}
		* { margin: 0; padding: 0; box-sizing: border-box; }
		html { scroll-behavior: smooth; }
		body {
			font-family: 'Poppins', sans-serif;
			background: linear-gradient(135deg, var(--light-dark-bg), var(--dark-bg));
			color: var(--text-color);
			min-height: 100vh;
			overflow: hidden;
			text-align: center;
		}

		#main-content {
			padding: 3rem 1.5rem;
			max-width: 1050px;
			margin: 0 auto;
		}
		.page-header {
			text-align: center;
			margin-bottom: 2.5rem;
		}
		.back-link { text-decoration: none; }
		.heading {
			font-weight: 700;
			font-size: clamp(2.5rem, 5vw, 3.5rem);
			color: #fff;
			text-shadow: 0 0 15px rgba(74, 222, 128, 0.6);
			transition: transform 0.3s ease;
		}
		.back-link:hover .heading { transform: scale(1.05); }

		.canvas-container {
			background: var(--card-bg);
			backdrop-filter: blur(10px);
			border: 1px solid var(--border-color);
			border-radius: 16px;
			padding: 1rem;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			margin-bottom: 2rem;
		}
		.grid {
			width: 100%;
			height: auto;
			border-radius: 8px;
		}

		.controls-panel {
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 1rem;
			flex-wrap: wrap;
			margin-bottom: 2rem;
		}
		.control-btn {
			background-color: var(--primary-color);
			color: var(--dark-bg);
			border: none;
			padding: 0.75rem 2rem;
			border-radius: 50px;
			font-weight: 600;
			font-size: 1rem;
			cursor: pointer;
			transition: all 0.3s ease;
		}
		.control-btn#reset-btn {
			background-color: var(--card-bg);
			color: var(--text-color);
			border: 1px solid var(--border-color);
		}
		.control-btn:hover { transform: scale(1.05); }
		.control-btn:disabled { background-color: #4b5563; cursor: not-allowed; }
		
		.status-display {
			background: var(--dark-bg);
			border: 1px solid var(--border-color);
			border-radius: 8px;
			padding: 0.75rem 1.5rem;
			font-size: 1rem;
			font-weight: 600;
			min-width: 200px;
		}
		.status-display .value { margin-left: 0.5rem; }
		.status-balanced { color: var(--primary-color); }
		.status-unbalanced { color: var(--fail-color); }
		.status-checking { color: var(--scan-color); }

		/* Legend */
		.legend { display: flex; justify-content: center; gap: 1.5rem; }
		.legend-item { display: flex; align-items: center; gap: 0.5rem; }
		.legend-color { width: 20px; height: 20px; border-radius: 4px; border: 1px solid var(--border-color); }
	</style>
</head>
<body>
	<div id="main-content">
		<div class="page-header">
			<a href="../stack.html" class="back-link"><h1 class="heading">Balanced Bracket</h1></a>
		</div>
		<div class="canvas-container">
			<canvas class='grid' width='1000' height='400'></canvas>
		</div>
		<div class="controls-panel">
			<div class="status-display">Status: <span class="value" id="status-text">Ready</span></div>
			<button class="control-btn" id="visualize-btn">Visualize</button>
			<button class="control-btn" id="reset-btn">Reset</button>
		</div>
		<div class="legend">
			<div class="legend-item"><div class="legend-color" style="background-color: var(--scan-color);"></div><span>Scanning</span></div>
			<div class="legend-item"><div class="legend-color" style="background-color: var(--primary-color);"></div><span>Match Found</span></div>
		</div>
	</div>

	<script>
		// --- Main Setup ---
		let sourceArr = [];
		let stack = [];
		const TIME_DELAY = 800;
		const BRACKET_ARR_SIZE = 10;
		
		const canvas = document.querySelector('canvas');
		const ctx = canvas.getContext("2d");
		
		const theme = {
			primary: getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(),
			scan: getComputedStyle(document.documentElement).getPropertyValue('--scan-color').trim(),
			fail: getComputedStyle(document.documentElement).getPropertyValue('--fail-color').trim(),
			text: getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim(),
			dark: getComputedStyle(document.documentElement).getPropertyValue('--dark-bg').trim(),
			cardBg: '#374151',
		};

		// --- Drawing Functions ---
		function render(scanIndex = -1, matchIndex = -1) {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawSourceArray(scanIndex, matchIndex);
			drawStack(matchIndex !== -1);
		}

		function drawSourceArray(scanIndex, matchIndex) {
			const rect = { width: 60, height: 40 };
			sourceArr.forEach((val, i) => {
				let bgColor = theme.cardBg;
				if (i === scanIndex) bgColor = theme.scan;
				if (i === matchIndex) bgColor = theme.primary;
				
				ctx.fillStyle = bgColor;
				ctx.fillRect(i * rect.width + i*5 + 10, canvas.height / 2 - rect.height/2, rect.width, rect.height);
				
				ctx.fillStyle = (i === scanIndex) ? theme.dark : theme.text;
				ctx.font = '600 20px Poppins';
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText(val, i * rect.width + i*5 + 10 + rect.width/2, canvas.height / 2);
			});
		}

		function drawStack(isMatch = false) {
			const stackWidth = 200;
			const stackX = canvas.width - stackWidth;
			const rectHeight = 30;

			ctx.strokeStyle = theme.primary;
			ctx.lineWidth = 3;
			ctx.strokeRect(stackX, 0, stackWidth, canvas.height);
			ctx.font = '700 18px Poppins';
			ctx.fillStyle = theme.primary;
			ctx.fillText("STACK", stackX + stackWidth / 2, canvas.height - 20);

			stack.forEach((val, i) => {
				const isTop = (i === stack.length - 1);
				const bgColor = (isTop && isMatch) ? theme.primary : theme.text;
				
				const y = canvas.height - (i + 1) * rectHeight - (i * 5);
				ctx.fillStyle = bgColor;
				ctx.fillRect(stackX + 10, y, stackWidth - 20, rectHeight);
				
				ctx.fillStyle = theme.dark;
				ctx.font = '600 20px Poppins';
				ctx.fillText(val, stackX + stackWidth / 2, y + rectHeight / 2);
			});
		}

		function updateStatus(status, text) {
			const statusEl = document.getElementById('status-text');
			statusEl.textContent = text;
			statusEl.className = `value status-${status}`;
		}
		
		// --- Main Logic ---
		async function visualize() {
			const button = document.getElementById("visualize-btn");
			button.disabled = true;
			updateStatus('checking', 'Checking...');

			let localSource = [...sourceArr];
			stack = [];
			
			for(let i=0; i < localSource.length; i++) {
				const char = localSource[i];
				render(i);
				await sleep(TIME_DELAY);

				if (char === '(') {
					stack.push(char);
					render(i);
				} else if (char === ')') {
					if (stack.length > 0 && stack[stack.length - 1] === '(') {
						render(i, i); // Highlight match
						await sleep(TIME_DELAY);
						stack.pop();
						render(i);
					} else {
						updateStatus('unbalanced', 'Not Balanced');
						button.disabled = false;
						return;
					}
				}
				await sleep(TIME_DELAY);
			}

			if (stack.length === 0) {
				updateStatus('balanced', 'Balanced');
			} else {
				updateStatus('unbalanced', 'Not Balanced');
			}
			button.disabled = false;
		}

		// --- Initialization and Helpers ---
		function initializeData() {
			sourceArr = [];
			const shouldBeBalanced = Math.random() > 0.4; // 60% chance to generate a balanced sequence
			if (shouldBeBalanced) {
				// Generate a guaranteed balanced sequence
				const tempStack = [];
				for(let i=0; i < BRACKET_ARR_SIZE; i++) {
					if (tempStack.length > 0 && Math.random() > 0.5) {
						sourceArr.push(')');
						tempStack.pop();
					} else {
						sourceArr.push('(');
						tempStack.push('(');
					}
				}
				while(tempStack.length > 0) {
					sourceArr.push(')');
					tempStack.pop();
				}
			} else {
				// Generate a random sequence (likely unbalanced)
				for(let i=0; i < BRACKET_ARR_SIZE; i++) {
					sourceArr.push(Math.random() > 0.5 ? '(' : ')');
				}
			}
		}

		function addListeners() {
			document.getElementById('visualize-btn').addEventListener('click', visualize);
			document.getElementById('reset-btn').addEventListener('click', init);
		}

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}
		
		function init() {
			document.getElementById("visualize-btn").disabled = false;
			initializeData();
			stack = [];
			render();
			updateStatus('ready', 'Ready');
		}
		
		addListeners();
		init();
	</script>
</body>
</html>
